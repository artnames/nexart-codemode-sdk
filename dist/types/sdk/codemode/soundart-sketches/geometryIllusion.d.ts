export declare const GEOMETRY_ILLUSION_SKETCH = "\nfunction setup() {\n  const bgMode = typeof backgroundMode !== 'undefined' ? backgroundMode : 'rgb';\n  if (bgMode === 'white') background(245, 245, 245);\n  else if (bgMode === 'black') background(10, 10, 10);\n  else {\n    const r = Math.floor((S.brightness / 100) * 255);\n    const g = Math.floor((S.rhythmicity / 100) * 255);\n    const b = Math.floor((S.harmonicity / 100) * 255);\n    background(r, g, b);\n  }\n\n  const hueBase = map(S.hue, 0, 100, 0, 360);\n  const hueVar = map(S.treble, 0, 100, 20, 240);\n  const sizeScale = map(S.volume, 0, 100, 0.05, 1.8);\n  const rotAmt = map(S.aggression, 0, 100, 0, PI / 3);\n  const layers = Math.floor(map(S.length, 0, 100, 120, 900));\n  const alphaLevel = map(S.amplitude, 0, 100, 0.25, 1.3);\n  const lineCount = Math.floor(map(S.rhythmicity, 0, 100, 40, 600));\n  const strokeW = map(S.attack, 0, 100, 0.5, 6.5);\n  const distort = map(S.harmonicity, 0, 100, 0, 70);\n  const bias = map(S.mid, 0, 100, 0, 1);\n  const bright = map(S.brightness, 0, 100, 0.4, 2.2);\n  const sat = map(S.chroma, 0, 100, 0.4, 5.4);\n  const cont = map(S.dynamicRange, 0, 100, 0.5, 3.4);\n  const layerDepth = map(S.harmonicity, 0, 100, 0.2, 2.2);\n\n  const baseScale = map(S.volume, 0, 100, 0.5, 1.1);\n  const densityScale = map(S.length, 0, 100, 0.9, 0.7);\n  const scaleFactor = constrain(baseScale * densityScale, 0.6, 1.0);\n\n  translate(width / 2, height / 2);\n  scale(scaleFactor, scaleFactor);\n\n  const combined = S.rhythmicity * 0.6 + S.harmonicity * 0.4;\n  const spacingFactor = map(combined, 0, 100, 2.5, 0.3);\n  const spacingAmp = map(S.volume, 0, 100, 0.3, 1.2);\n\n  for (let i = 0; i < layers; i++) {\n    push();\n    rotate((random() - 0.5) * rotAmt * 2);\n    \n    const w = random() * width * sizeScale;\n    const h = random() * height * sizeScale;\n    \n    translate(\n      (random() - 0.5) * width * spacingFactor * spacingAmp,\n      (random() - 0.5) * height * spacingFactor * spacingAmp\n    );\n\n    const hue = (hueBase + random() * hueVar - hueVar / 2 + 360) % 360;\n    const fillSat = constrain(60 * sat, 0, 100);\n    const fillLight = constrain(60 * bright * cont, 0, 100);\n    const strokeLight = constrain(30 * cont, 0, 100);\n\n    fill(hslColor(hue, fillSat, fillLight, alphaLevel * layerDepth));\n    stroke(hslColor(hue, fillSat * 0.6, strokeLight, alphaLevel));\n    strokeWeight(strokeW);\n\n    const rectW = w * (bias > 0.5 ? lerp(0.5, 1.0, random()) : lerp(0.1, 0.5, random()));\n    const rectH = h * (bias < 0.5 ? lerp(0.5, 1.0, random()) : lerp(0.1, 0.5, random()));\n\n    rect(\n      -rectW / 2 + (random() - 0.5) * distort,\n      -rectH / 2 + (random() - 0.5) * distort,\n      rectW,\n      rectH\n    );\n    pop();\n  }\n\n  noFill();\n  stroke(hslColor(hueBase, 25, 75, 0.25));\n  strokeWeight(1);\n  for (let i = 0; i < lineCount; i++) {\n    const x1 = random() * width - width / 2;\n    const y1 = random() * height - height / 2;\n    const x2 = x1 + lerp(-100, 100, random());\n    const y2 = y1 + lerp(-100, 100, random());\n    line(x1, y1, x2, y2);\n  }\n}\n\nfunction hslColor(h, s, l, a) {\n  if (a !== undefined) return 'hsla(' + h + ',' + s + '%,' + l + '%,' + a + ')';\n  return 'hsl(' + h + ',' + s + '%,' + l + '%)';\n}\n";
export default GEOMETRY_ILLUSION_SKETCH;
//# sourceMappingURL=geometryIllusion.d.ts.map