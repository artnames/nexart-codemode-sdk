/**
 * Flow Grid Rings - SoundArt Style as Code Mode Sketch
 *
 * This is the first SoundArt style converted to a Code Mode sketch.
 * It uses S.* globals (sound snapshot) instead of direct sound data.
 *
 * Original: client/src/pages/soundart/engine/styles_impl.ts - drawFlowGridRings
 */
export declare const RINGS_SKETCH = "\n// Flow Grid Rings - SoundArt Style\n// Uses S.* sound globals and standard p5-like functions\n\nfunction setup() {\n  // Set background based on mode (rgb derived from sound, black, or white)\n  const bgMode = typeof backgroundMode !== 'undefined' ? backgroundMode : 'rgb';\n  \n  if (bgMode === 'white') {\n    background(245, 245, 245);\n  } else if (bgMode === 'black') {\n    background(10, 10, 10);\n  } else {\n    // Deterministic RGB background derived from sound snapshot\n    // Previously used clock time, now uses sound parameters for reproducibility\n    const r = Math.floor((S.brightness / 100) * 255);\n    const g = Math.floor((S.rhythmicity / 100) * 255);\n    const b = Math.floor((S.harmonicity / 100) * 255);\n    background(r, g, b);\n  }\n  \n  // Grid dimensions based on sound volume\n  const cols = Math.floor(map(S.volume, 0, 100, 2, 32));\n  const rows = Math.floor(cols * 1.5);\n  const margin = map(S.length, 0, 100, width * 0.05, width * 0.1);\n  const innerW = width - margin * 2;\n  const innerH = height - margin * 2;\n  const cellW = innerW / cols;\n  const cellH = innerH / rows;\n  const gap = Math.min(cellW, cellH) * 0.25;\n  const maxRadius = (Math.min(cellW, cellH) - gap) / 2;\n  \n  // Palette Harmony based on sound\n  const mainHue = (S.brightness * 3.6) % 360;\n  const hueShift = map(S.harmonicity, 0, 100, 20, 60);\n  const sat = map(S.treble, 0, 100, 60, 90);\n  const bri = map(S.bass, 0, 100, 70, 95);\n  \n  // Generate palette\n  const palette = [\n    hslColor(mainHue, sat, bri),\n    hslColor((mainHue + hueShift) % 360, sat - 10, bri + 5),\n    hslColor((mainHue - hueShift + 360) % 360, sat - 10, bri + 5),\n    hslColor((mainHue + 180) % 360, sat - 20, bri - 10),\n    hslColor((mainHue + 120) % 360, sat, bri - 5),\n    hslColor((mainHue + 240) % 360, sat, bri - 5),\n  ];\n  \n  // Flow field parameters\n  const noiseScale = 0.15;\n  const noiseStrength = map(S.aggression, 0, 100, 0.5, 4.0);\n  const jitter = map(S.rhythmicity, 0, 100, 0, 0.15);\n  const ringBias = map(S.attack, 0, 100, 0.85, 1.15);\n  \n  noStroke();\n  \n  // Render Grid\n  for (let gx = 0; gx < cols; gx++) {\n    for (let gy = 0; gy < rows; gy++) {\n      const cx = margin + gx * cellW + cellW / 2 + (random() - 0.5) * jitter * cellW;\n      const cy = margin + gy * cellH + cellH / 2 + (random() - 0.5) * jitter * cellH;\n      \n      const n = noise(gx * noiseScale, gy * noiseScale);\n      const angle = n * PI * 2 * noiseStrength;\n      const rings = Math.max(1, Math.floor(map(sin(angle), -1, 1, 1, 6)));\n      const step = (maxRadius / rings) * ringBias * 0.9;\n      \n      for (let i = rings; i > 0; i--) {\n        fill(palette[(rings - i) % palette.length]);\n        ellipse(cx, cy, i * step * 2, i * step * 2);\n      }\n    }\n  }\n}\n\n// Helper function for HSL colors\nfunction hslColor(h, s, l) {\n  return 'hsl(' + h + ',' + s + '%,' + l + '%)';\n}\n";
export default RINGS_SKETCH;
//# sourceMappingURL=rings.d.ts.map